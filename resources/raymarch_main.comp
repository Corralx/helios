void normal(in vec3 point, out vec3 normal)
{
	const vec3 v = vec3(normal_epsilon, 0, 0);

	normal = normalize(vec3(
		scene(point + v) - scene(point - v),
		scene(point + v.yxz) - scene(point - v.yxz),
		scene(point + v.zyx) - scene(point - v.zyx)));
}

float shadow(in vec3 origin, in vec3 light_vector, in float k)
{
	float res = 1.0;

    for (float t = shadow_starting_step; t < shadow_max_step; )
    {
        float h = scene(origin + light_vector * t);

        if (h < shadow_epsilon)
            return 0.0;

		if (soft_shadow)
			res = min(res, k * h / t);

        t += h;
    }

    return res;
}

float ambient_occlusion(in vec3 point, in vec3 normal)
{
	float step_size = ambient_occlusion_step;
	float t = step_size;
	float oc = 0.0f;
	for (int i = 0; i < ambient_occlusion_iterations; ++i)
	{
		float d = scene(point + normal * t);
		oc += t - d;
		t += step_size;
	}

	return clamp(oc, .0f, 1.f);
}


void shade(in vec3 p, in vec3 light_vector, out vec3 color)
{
	vec3 n;
	normal(p, n);

	float l_dot_n = max(dot(light_vector, n), 0.0);

	color = light_color * l_dot_n;

	if (enable_shadow)
		color *= shadow(p, light_vector, shadow_quality) + 0.2f;

	if (enable_ambient_occlusion)
		color *= 1.0f - ambient_occlusion(p, n);

	color = clamp(color, vec3(0.0), vec3(1.0));
}

void main()
{	
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    if (coord.x > (screen_width - 1) || coord.y > (screen_height - 1))
    	return;

    float screen_width_f = screen_width;
    float screen_height_f = screen_height;
    float aspect_ratio = screen_width_f / screen_height_f;

	vec3 light_vector = normalize(-light_direction);

	float t = starting_step;
	int iterations;

	float u = coord.x * 2.0 / screen_width_f - 1.0;
    float v = coord.y * 2.0 / screen_height_f - 1.0;

    vec3 ray_dir = normalize(camera_view * focal_length + camera_right * u * aspect_ratio + camera_up * v);

	vec3 p = vec3(0.0);
	vec3 color_out = vec3(0.0, 1.0, 0.0);

	for (iterations = 0; iterations < max_iterations; ++iterations)
    {
	    p = camera_position + ray_dir * t;
        float d = scene(p);
		
		t += d;
		if (t > z_far)
			break;

		if (d < epsilon)
		{
			shade(p, light_vector, color_out);
			break;
		}
    }

	imageStore(output_image, coord, vec4(color_out, 1.0));
}
