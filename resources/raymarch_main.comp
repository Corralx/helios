void approximate_normal(in vec3 point, out vec3 normal)
{
	const vec3 v = vec3(normal_epsilon, 0, 0);

	normal = normalize(vec3(
		scene(point + v) - scene(point - v),
		scene(point + v.yxz) - scene(point - v.yxz),
		scene(point + v.zyx) - scene(point - v.zyx)));
}

float shadow(in vec3 origin, in vec3 light_vector, in float k)
{
	float res = 1.0;

    for (float t = shadow_starting_step; t < shadow_max_step; )
    {
        float h = scene(origin + light_vector * t);

        if (h < shadow_epsilon)
            return 0.0;

		if (soft_shadow)
			res = min(res, k * h / t);

        t += h;
    }

    return res;
}

float ambient_occlusion(in vec3 point, in vec3 normal)
{
	float step_size = ambient_occlusion_step;
	float t = step_size;
	float oc = 0.0f;
	for (int i = 0; i < ambient_occlusion_iterations; ++i)
	{
		float d = scene(point + normal * t);
		oc += t - d;
		t += step_size;
	}

	return saturate(oc);
}

// http://www.iquilezles.org/www/articles/fog/fog.htm
void apply_fog_simple(inout vec3 color, in float dist)
{
    float fogAmount = 1.0 - exp( -dist * 0.2 );
    vec3  fogColor  = vec3(0.5,0.6,0.7);
    color = mix(color, fogColor, fogAmount);
}

vec3 shade(in vec3 p, in vec3 n, in vec3 color)
{
	vec3 light_vector = normalize(-light_direction);
	float l_dot_n = max(dot(light_vector, n), 0.0);

	vec3 color_out = light_color * l_dot_n * color;

	if (enable_shadow)
		color_out *= shadow(p, light_vector, shadow_quality) + 0.2f;

	if (enable_ambient_occlusion)
		color_out *= 1.0f - ambient_occlusion(p, n);

	return saturate(color_out);
}

vec3 floor_color(in vec3 point)
{
	vec2 m = mod(point.xz, 2.0) - vec2(1.0);
	return m.x * m.y > 0.0 ? vec3(0.1) : vec3(1.0);
}

void raymarch(in vec3 ro, in vec3 rd, inout int it, out float dist)
{
	dist = starting_step;

	for (it = 0; it < max_iterations; ++it)
    {
        float d = scene(ro + rd * dist);

		if (d < epsilon * dist || dist > z_far)
			break;

		dist += d;
    }

	dist = clamp(dist, 0.0, z_far);
}

vec3 compute_color(in vec3 ro, in vec3 rd)
{
	vec3 point;
	vec3 normal;

	float t;
	int iterations;

	vec3 base_color;

	raymarch(ro, rd, iterations, t);
	float floor_dist = dot(vec3(0.0, -0.3, 0.0) - ro, vec3(0.0, 1.0, 0.0)) / dot(rd, vec3(0.0, 1.0, 0.0));

	if (floor_dist < t && floor_dist < z_far && floor_dist > 0.0)
	{
		// Floor surface
		t = floor_dist;
		point = ro + rd * t;
		normal = vec3(0.0, 1.0, 0.0);
		base_color = floor_color(point);
	}
	else if (iterations < max_iterations && t < z_far)
	{
		// Primitive surface
		point = ro + rd * t;
		approximate_normal(point, normal);
		base_color = vec3(1.0, 1.0, 1.0); // TODO(Corralx): Fetch color from primitive ID
	}
	else
	{
		// Sky
		return vec3(0.0, 1.0, 0.0);
	}

	return shade(point, normal, base_color);
}

void main()
{	
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    if (coord.x > (screen_width - 1) || coord.y > (screen_height - 1))
    	return;

	vec2 resolution = vec2(screen_width, screen_height);
    float aspect_ratio = resolution.x / resolution.y;

	float u = coord.x * 2.0 / resolution.x - 1.0;
    float v = coord.y * 2.0 / resolution.y - 1.0;

    vec3 ray_dir = normalize(camera_view * focal_length + camera_right * u * aspect_ratio + camera_up * v);

	vec3 color_out = compute_color(camera_position, ray_dir);
	imageStore(output_image, coord, vec4(color_out, 1.0));
}
